"use strict";

const Errors = {};

// dictionary of all possible error types {type:{description:string}}
const errorTypes = {};

/*
  Abstract base class for all errors. Following extra properties are available for all classes :
  - origin : client|exchange|remote
  - errorType : string (ex: GatewayError.InvalidRequest.InvalidParameter)
  - data : custom data with extra information (ex: {parameterName:string, parameterValue:string})
*/
class BaseError extends Error
{

/**
 * @param {string} message error message
 * @param {object} data custom data
 */
constructor(message, data)
{
    super(message);
    if (BaseError === this.constructor)
    {
        throw new TypeError(`Cannot instantiate '${this.constructor.name}' directly`);
    }
    this.data = data;
}

toJSON()
{
    return this.toHash();
}

inspect()
{
    let arr = this.stack.split('\n');
    arr[0] = this.toString();
    return arr.join('\n');
}

/**
 * Whether or not error is of a given type (ex: ExchangeError.InvalidRequest)
 *
 * @param {string} errorType type of the error (ex: ExchangeError.InvalidRequest)
 */
instanceOf(errorType)
{
    return 0 === this.errorType.indexOf(errorType);
}

toString()
{
    return `${this.errorType}: ${this.message}`
}

toHash()
{
    let obj = {
        origin:this.origin,
        errorType:this.errorType,
        message:this.message,
        data:this.data
    }
    if (undefined !== this.route)
    {
        obj.route = this.route;
    }
    if (undefined !== this.httpCode)
    {
        obj.httpCode = this.httpCode;
    }
    return obj;
}

}

Errors.BaseError = BaseError;

/**
 * Factory function used to declare classes in module Errors
 *
 * @param {string} errorType fully qualified error type (ex: ClientError.InvalidRequest.InvalidArgument)
 * @param {class} newClass class definition
 * @param {string} description error description
 */
function createClass(errorType, newClass, httpCode, description)
{
    errorTypes[errorType] = {description:description};
    newClass.prototype.origin = 'client';
    newClass.prototype.errorType = errorType;
    let arr = errorType.split('.');
    let className = arr.pop();
    let container = Errors;
    let containerName = '';
    for (let i = 0; i < arr.length; ++i)
    {
        if (undefined === container[arr[i]])
        {
            if ('' != containerName)
            {
                containerName += '.';
            }
            containerName += arr[i];
            container[arr[i]] = {
                [Symbol.hasInstance]:function(obj){
                    if (undefined === obj.errorType)
                    {
                        return false;
                    }
                    return 0 === obj.errorType.indexOf(containerName);
                }
            }
        }
        container = container[arr[i]];
    }
    container[className] = newClass;
}

/**
 * Extract error message from an error
 * @param {string} defaultMessage message to use as fallback
 * @param {string|object} message
 * @return {string} message
 */
function getErrorMessage(defaultMessage, message)
{
    if (undefined === message || null === message || '' == message)
    {
        return defaultMessage;
    }
    return message;
}

/*
 * Error generated by client when a request is invalid
 */
createClass('Client.InvalidRequest.UnknownError', class extends BaseError {

/**
 * @param {string} message error message (optional)
 */
constructor(message)
{
    let m = 'Invalid request';
    if ('string' == typeof message && '' != message)
    {
        m = message;
    }
    super(m, {});
}

}, 'Error generated by client when a request is invalid'); // Client.InvalidRequest.UnknownError

/*
 * Error generated by client when a method was called with an invalid parameter
 */
createClass('Client.InvalidRequest.InvalidParameter', class extends BaseError {

/**
 * @param {string} parameterName name of the invalid parameter
 * @param {string|number|boolean|object} parameterValue value of the invalid parameter
 * @param {string} message error message (optional)
 * @param {boolean} cannotBeEmpty if true a message will be generated to indicate that value cannot be empty (unless a custom message exist)
 */
constructor(parameterName, parameterValue, message, cannotBeEmpty)
{
    let defaultMessage = `Parameter '${parameterName}' is invalid`;
    if (undefined !== cannotBeEmpty && true === cannotBeEmpty)
    {
         defaultMessage = `Parameter '${parameterName}' cannot be empty`;
    }
    let data = {
         parameterName:parameterName,
         parameterValue:parameterValue
    };
    super(getErrorMessage(defaultMessage, message), data);
}

}, 'Error generated by client when a method was called with an invalid parameter'); // Client.InvalidRequest.InvalidParameter

/*
 * Used when a request to gateway times out
 */
createClass('ClientError.NetworkError.RequestTimeout', class extends BaseError {

/**
 * @param {string} message error message or object (optional)
 */
constructor(message)
{
    let defaultMessage = `Request timed out when trying to contact gateway`;
    super(getErrorMessage(defaultMessage, message), {});
}

}, 'Used when a request to gateway times out'); // ClientError.NetworkError.RequestTimeout

/*
 * Used when an unknown http error occurs when trying to contact gateway
 */
createClass('ClientError.NetworkError.UnknownError', class extends BaseError {

/**
 * @param {string} message error message or object (optional)
 */
constructor(message)
{
    let defaultMessage = `A network error occured when trying to contact gateway`;
    super(getErrorMessage(defaultMessage, message), {});
}

}, 'Used when an unknown http error occurs when trying to contact gateway'); // ClientError.NetworkError.UnknownError

/**
 * Errors returned by gateway
 */
class RemoteError extends BaseError
{

/**
 * @param {integer} httpCode http code sent by gateway
 * @param {object} error error object returned by gateway
 */
constructor(httpCode, error)
{
    super(error.extError.message, error.extError.data);
    this.origin = error.origin;
    this.errorType = error.extError.errorType;
    this.httpCode = httpCode;
    this.route = error.route;
}

}

Errors.RemoteError = RemoteError;

/**
 * Returns the list of all possible error types
 *
 * @return {string[]}
 */
Errors.types = () => {
    return Object.keys(errorTypes).sort();
}

/**
 * List all possible errors with description
 * @return [{type:string,description:string}]
 */
Errors.list = () => {
    let list = [];
    let types = Object.keys(errorTypes).sort();
    for (let i = 0; i < types.length; ++i)
    {
        list.push({type:types[i], description:errorTypes[types[i]].description});
    }
    return list;
}

module.exports = Errors;
